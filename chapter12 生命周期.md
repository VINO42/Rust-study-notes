chapter12 生命周期
==================

#### 生命周期

借出一个其他人所有资源的引用可以是很复杂的。例如以下操作：

- 我获取了一个某种资源的句柄
- 我借给你了一个关于这个资源的引用
- 我决定不再需要这个资源了，然后释放了它，这时你仍然持有它的引用
- 你决定使用这个资源

你的引用指向一个无效的资源。这叫做悬垂指针，如果这个资源是内存的话。

如果要修正这个问题，我们必须确保第四步永远也不在第三步之后发生。Rust 所有权系统通过一个叫生命周期的概念来做到这一点，它定义了一个引用有效的作用域。

当我们有一个获取引用作为参数的函数，我们可以隐式或显式涉及到引用的生命周期：

```rust
// implicit
fn foo(x: &i32) {
}

// explicit
fn bar<'a>(x: &'a i32) {
}
```

`'a` 读作“生命周期 a”。技术上讲，每一个引用都有着一些与之相关的生命周期，不过通常情况下编译器可以让你省略它们。这是显式的：

```rust
fn bar<'a>(...)
```

之前在讨论函数的时候并没有讨论函数名后面的 `<>`。一个函数可以在 `<>` 之间有“泛型参数”，生命周期也是其中一种。后续章节会介绍其他类型的泛型，现在先来看生命周期。

我们用 `<>` 声明了生命周期。这是说 `bar` 有一个生命周期 `'a`。如果我们有两个引用参数，它看起来应该是这样：

```rust
fn bar<'a, 'b>(...)
```

接着在我们的参数列表中，我们使用了我们命名的生命周期：

```rust
...(x: &'a i32)
```

如果想要一个 `&mut` 引用，可以这么做：

```rust
...(x: &'a mut i32)
```

如果对比一下 `&mut i32` 和 `&'a mut i32`，它们是一样的，只是后者在 `&` 和 `mut i32` 之间夹了一个生命周期 `'a`。`&mut i32` 读作“一个 `i32` 的可变引用”，而 `&'a mut i32` 读作“一个带有生命周期 `'a` 的 `i32` 的可变引用。

#### 在 `struct` 中

未完待续~