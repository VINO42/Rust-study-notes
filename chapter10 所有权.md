chapter10 所有权
================

所有权系统是 Rust 最独特且最引人入胜的特性之一，也是作为 Rust 开发者应该熟悉的。Rust 所追求的最大目标——内存安全，关键在于所有权。

#### 原则

Rust 注重安全和速度。它通过很多零开销抽象来实现这些目标，也就是说在 Rust 中，实现抽象的开销尽可的小。所有权系统是一个典型的零开销抽象的例子。本文提到的所的分析都是在编译时完成的。你不需要在运行时为这些功能付出任何开销。

然而，这个系统确实有一个开销：学习曲线。很多 Rust 初学者会经历所谓的“与借用检查器作斗争”的过程，也就是指 Rust 编译器拒绝编译一个作者认为合理的程序。这种“斗争”会因为程序员关于所有权系统如何工作的基本模型与 Rust 实现的实际规则不匹配而经常发生。不过，一旦适应所有权系统一段时间后，与借用检查器的冲突会越来越少。

#### 所有权（Ownership)

Rust 中的变量绑定有一个属性：它们有它们所绑定的值的所有权。这意味着当一个绑定离开作用域，它们绑定的资源就会被释放。例如：

```rust
fn foo() {
    let v = vec![1, 2, 3];
}
```

当 `v` 进入作用域，一个新的 Vector 在栈上被创建，并在堆上为它的3个元素分配了内存空间。当 v 在 foo() 的末尾离开作用域，Rust 将会清理掉与 Vector 相关的一且，包括在堆上分配的内存。这在作用域的结尾是一定会发生的。

##### 绑定

准确的说，Rust 中并没有变量这一概念，而应该称为 `标识符`，目标 `资源` （内存，存放 value）`绑定` 到这个标识符：

```rust
{
    let x: i32;       // 标识符x，没有绑定任何资源
    let y: i32 = 100; // 标识符y，绑定资源100
}
```

继续看下一段代码：

```rust
{
    let a: i32;
    println!("{}", a);
}
```

上面定义了一个 i32 类型的标识符 `a`，如果你直接 `println!`，你会收到一个 error：

```
error: use of possibly uninitialized variable: a
```

这是因为 Rust 并不会像其他语言一样可以为变量默认初始化值，Rust 明确规定变量的初始化值必须有程序员自己决定。

正确的做法：

```rust
{
    let a: i32;
    a = 100; // 必须初始化 a
    println!("{}", a);
}
```

实际上，`let` 关键字并不只是声明变量的意思，它还有一层特殊且重要的概念——绑定。通俗的讲，`let` 关键字可以把一个标识符和一段内存区域做“绑定”，绑定后，这段内存就是被这个标识符所拥有，这个标识符也成为这段内存的唯一所有者。所以，`a = 100` 发生了这么几个动作，首先在栈上分配一个 `i32` 的资源，并填充值 `100`，随后，把这个资源与 `a` 做绑定，让 `a` 成为资源的所有者（Owner）。

##### 作用域

Rust 通过 `{}` 大括号定义作用域：

```rust
{
    {
        let a: i32 = 100;
    }
    println!("{}", a);
}
```

编译时会得到如下错误：

```
error[E0425]: unresolved name `a`
 --> main.rs:6:24
  |
6 |         println!("{}", a);
  |                        ^ unresolved name
```

在局部变量离开作用域后，变量随即被销毁。并且，Rust 会连同变量绑定的内存，不管是否为常量字符串，连同所有者变量一起被销毁释放。所以上面的例子，`a` 销毁后再次访问 `a` 就会提示无法找到变量 `a` 的错误。这些都是在编译过程中完成的。

#### 移动语义

这里有更巧妙的地方：Rust 确保了对于任何给定的资源都正好（只）有一个绑定与之对应。例如，如果我们有一个 Vector，我们可以把它赋予另外一个绑定：

```rust
let v = vec![1, 2, 3];

let v2 = v;
```

不过，如果之后尝试使用 `v`，将得到一个错误：

```rust
let v = vec![1, 2, 3];

let v2 = v;

println!("v[0] is: {}", v[0]);
```

```
error: use of moved value: `v`
println!("v[0] is: {}", v[0]);
```

当哦我们定义了一个取得所有权的函数，并尝试在我们把变量作为参数传递给函数之后用这个变量时，会发生相似的事情：

```rust
fn take(v: Vec<i32>) {

}

let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]);
```

一样的错误：“use of moved value”。当把所有权转移给别的绑定时，我们说我们“移动 （move）”了我们引用的值。这里你并不需要什么类型的特殊注解，这是 Rust 的默认行为。

##### 细节

在移动了绑定后我们不能使用它的原因是微妙的，也是重要的。当我们写了这样的代码：

```rust
let x = 10;
```

Rust 在栈上为一个整型（i32）分配了内存，将代表值 10 的位拷贝到分配的内存中并将这个内存区域绑定到变量 x 上以供进一步引用。

现在考虑一下下面的代码段：

```rust
let v = vec![1, 2, 3];

let mut v2 = v;
```

第一行在栈上为 Vector 对象 `v` 分配了内存，就像上面的 `v` 一样。不过同时它也在堆上为实际的数据 `[1, 2, 3]` 分配了一些内存。Rust 拷贝堆上分配的内存的地址到一个内部指针，作为位于栈上的 Vector 对象的一部分（可以叫它数据指针）。要指出的是，我们也将 Vector 对象和它的数据存储在不同的内存区域，而不是分配到一块连续的内存中。Vector 的这两部分在任何时候都必须同步像大小，容量这样的信息。

当我们从 `v` 移动到 `v2`，Rust 实际上按位拷贝了 `v` 在栈上分配的内容到 `v2`。这样浅拷贝并没有复制一份堆分配的实际数据。这就是说将会有两个 Vector 内容的指针都指向通过堆上分配的空间。这样会违反 Rust 的安全保证，通过引入一个数据竞争，当你可以同时访问 `v` 和 `v2` 的时候。

例如如果我们通过 `v2` 缩短 Vector 到只有两个元素：

```rust
let v = vec![1, 2, 3];
let mut v2 = v;
v2.truncate(2);
```

而同时 `v` 仍是可以访问的话，这会产生一个无效的 Vector，因为它并不知道堆上的数据已经被缩短了。现在 `v` 在栈上的部分与堆上的相应部分色信息并不一致。`v` 仍然认为有3个元素并乐意我们访问那个并不存在的元素 `v[2]`，不过你可能已经知道这是一个导致灾难的剧本。因为这可能会导致一个段错误，更糟糕的是会允许未经授权的用户读取它们没有访问权限的数据。

这就是为何 Rust 在我们移动后禁止使用 `v` 的原因。

注意到优化可能会根据情况移除栈上字节的实际拷贝也是很重要的，所以它也许并不像它开始看起来那样没有效率。

也许还会有疑问，move 后，`v` 和 `v2` 离开作用域，会不会有“Double Free”的问题？不过，Rust 规定，只有资源的所有者销毁后才释放内存，而无论这个资源是否被多次 move，同一时刻只有一个所有者（Owner），所以该资源的内存也只会被 free 一次。

#### Copy 类型

我们已经知道了当所有权被转移给另一个绑定以后，不能再使用原始绑定。然而，有一个叫做 `Copy` 的 trait 会改变这个行为。例如：

```rust
let v = 1;
let v2 = v;
println!("v is: {}", v);
```

这段代码没有问题，是因为 `v` 是一个 `i32`，它实现了 `Copy`。这意味这，就像一个移动，当我们把 `v` 赋值给 `v2`，产生了一个数据的拷贝。不过，不像一个移动，我们仍可以在之后使用 `v`。这是因为 `132` 并没有指向其他数据的指针，对它的拷贝是一个完整的拷贝。

所有基本类型都实现了 `Copy` trait，因此他们的所有权并不像你想象的那样遵循“所有权规则”被移动。作为一个例子，如下两段代码能够编译是因为 `i32` 和 `bool` 类型实现了 `Copy` trait。

```rust
fn main() {
    let a = 5;

    let _y = double(a);
    println!("{}", a);
}

fn double(x: i32) -> i32 {
    x * 2
}
```

```rust
fn main() {
    let a = true;

    let _y = change_truth(a);
    println!("{}", a);
}

fn change_truth(x: bool) -> bool {
    !x
}
```

如果使用了没有实现 `Copy` trait 的类型，会得到一个编译错误，因为我们尝试使用一个移动了的值。

```
error: use of moved value: `a`
println!("{}", a);
```

在[标准库文档](https://doc.rust-lang.org/std/marker/trait.Copy.html)中也有对 `Copy` trait 的介绍。

一旦一种类型实现了 `Copy` tarit，这就意味这这种类型可以通过简单的位拷贝实现拷贝。从前面的知识我们知道“绑定”存在 move 语义（所有权转移），但是，一旦这种类型实现了 `Copy` tarit，会先拷贝内容到新的内存区域，然后将新内存区域跟这个标识符做绑定。

也可以给自定义类型实现 `Copy` tarit，只要这种类型的属性类型都实现了 `Copy` tarit，这个类型就可以实现 `Copy` tarit。例如：

```rust
// 可实现
struct Foo {
    a: i32,
    b: bool,
}

// 不可实现
struct Bar {
    l: Vec<i32>,
}
```

因为 `Foo` 的属性 `a` 和 `b` 的类型 `i32` 和 `bool` 均实现了 `Copy` tarit，所以 `Foo` 可以实现 `Copy` tarit。但对于 `Bar` 来说，它的属性 `l` 是 `Vec<T>` 类型，这种类型并没有实现 `Copy` tarit，所以 `Bar` 无法实现 `Copy` tarit。

有两种方法为自定义类型实现 `Copy` tarit。

1. 通过 `derive` 让编译器自动实现

```rust
#[derive(Copy, Clone)]
struct Foo {
    a: i32,
    b: bool,
}
```

2. 手动实现

```rust
#[derive(Debug)]
struct Foo {
   a: i32,
   b: bool,
}
impl Copy for Foo {}
impl Clone for Foo {
    fn clone(&self) -> Foo {
        Foo{a: self.a, b: self.b}
    }
}
fn main() {
    let x = Foo{ a: 100, b: true};
    let mut y = x;
    y.b = false;

    println!("{:?}", x);  //打印：Foo { a: 100, b: true }
    println!("{:?}", y);  //打印：Foo { a: 100, b: false }
 }
```

 


