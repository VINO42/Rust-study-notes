chapter10 所有权
================

所有权系统是 Rust 最独特且最引人入胜的特性之一，也是作为 Rust 开发者应该熟悉的。Rust 所追求的最大目标——内存安全，关键在于所有权。

#### 原则

Rust 注重安全和速度。它通过很多零开销抽象来实现这些目标，也就是说在 Rust 中，实现抽象的开销尽可的小。所有权系统是一个典型的零开销抽象的例子。本文提到的所的分析都是在编译时完成的。你不需要在运行时为这些功能付出任何开销。

然而，这个系统确实有一个开销：学习曲线。很多 Rust 初学者会经历所谓的“与借用检查器作斗争”的过程，也就是指 Rust 编译器拒绝编译一个作者认为合理的程序。这种“斗争”会因为程序员关于所有权系统如何工作的基本模型与 Rust 实现的实际规则不匹配而经常发生。不过，一旦适应所有权系统一段时间后，与借用检查器的冲突会越来越少。

#### 所有权（Ownership)

Rust 中的变量绑定有一个属性：它们有它们所绑定的值的所有权。这意味着当一个绑定离开作用域，它们绑定的资源就会被释放。例如：

```rust
fn foo() {
    let v = vec![1, 2, 3];
}
```

当 `v` 进入作用域，一个新的 Vector 在栈上被创建，并在堆上为它的3个元素分配了内存空间。当 v 在 foo() 的末尾离开作用域，Rust 将会清理掉与 Vector 相关的一且，包括在堆上分配的内存。这在作用域的结尾是一定会发生的。

##### 绑定

准确的说，Rust 中并没有变量这一概念，而应该称为 `标识符`，目标 `资源` （内存，存放 value）`绑定` 到这个标识符：

```rust
{
    let x: i32;       // 标识符x，没有绑定任何资源
    let y: i32 = 100; // 标识符y，绑定资源100
}
```

继续看下一段代码：

```rust
{
    let a: i32;
    println!("{}", a);
}
```

上面定义了一个 i32 类型的标识符 `a`，如果你直接 `println!`，你会收到一个 error：

```
error: use of possibly uninitialized variable: a
```

这是因为 Rust 并不会像其他语言一样可以为变量默认初始化值，Rust 明确规定变量的初始化值必须有程序员自己决定。

正确的做法：

```rust
{
    let a: i32;
    a = 100; // 必须初始化 a
    println!("{}", a);
}
```

实际上，`let` 关键字并不只是声明变量的意思，它还有一层特殊且重要的概念——绑定。通俗的讲，`let` 关键字可以把一个标识符和一段内存区域做“绑定”，绑定后，这段内存就是被这个标识符所拥有，这个标识符也成为这段内存的唯一所有者。所以，`a = 100` 发生了这么几个动作，首先在栈上分配一个 `i32` 的资源，并填充值 `100`，随后，把这个资源与 `a` 做绑定，让 `a` 成为资源的所有者（Owner）。

##### 作用域

Rust 通过 `{}` 大括号定义作用域：

```rust
{
    {
        let a: i32 = 100;
    }
    println!("{}", a);
}
```

编译时会得到如下错误：

```
error[E0425]: unresolved name `a`
 --> main.rs:6:24
  |
6 |         println!("{}", a);
  |                        ^ unresolved name
```

在局部变量离开作用域后，变量随即被销毁。并且，Rust 会连同变量绑定的内存，不管是否为常量字符串，连同所有者变量一起被销毁释放。所以上面的例子，`a` 销毁后再次访问 `a` 就会提示无法找到变量 `a` 的错误。这些都是在编译过程中完成的。

#### 移动语义

